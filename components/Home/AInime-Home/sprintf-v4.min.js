! function(t, a) {
    "undefined" != typeof module ? module.exports = a() : "function" == typeof define && "object" == typeof define.amd ? define(a) : this.sprintf = a()
}(this, function() {
    var t = function(t) {
        if ("string" != typeof t) throw "sprintf: The first arguments need to be a valid format string.";
        for (var a = new RegExp(/%(\+)?([0 ]|'(.))?(-)?([0-9]+)?(\.([0-9]+))?([%bcdfosxX])/g), e = [], r = 1; part = a.exec(t);) {
            if (r >= arguments.length && "%" != part[8]) throw "sprintf: At least one argument was missing.";
            e[e.length] = {
                begin: part.index,
                end: part.index + part[0].length,
                sign: "+" == part[1],
                negative: parseFloat(arguments[r]) < 0 ? !0 : !1,
                padding: void 0 == part[2] ? " " : "'" == part[2].substring(0, 1) ? part[3] : part[2],
                alignLeft: "-" == part[4],
                width: void 0 != part[5] ? part[5] : !1,
                precision: void 0 != part[7] ? part[7] : !1,
                type: part[8],
                data: "%" != part[8] ? String(arguments[r++]) : !1
            }
        }
        for (var n = "", i = 0, s = 0; s < e.length; ++s) {
            n += t.substring(i, e[s].begin), i = e[s].end;
            var p = "";
            switch (e[s].type) {
                case "%":
                    p = "%";
                    break;
                case "b":
                    p = Math.abs(parseInt(e[s].data)).toString(2);
                    break;
                case "c":
                    p = String.fromCharCode(Math.abs(parseInt(e[s].data)));
                    break;
                case "d":
                    p = String(Math.abs(parseInt(e[s].data)));
                    break;
                case "f":
                    p = e[s].precision === !1 ? String(Math.abs(parseFloat(e[s].data))) : Math.abs(parseFloat(e[s].data)).toFixed(e[s].precision);
                    break;
                case "o":
                    p = Math.abs(parseInt(e[s].data)).toString(8);
                    break;
                case "s":
                    p = e[s].data.substring(0, e[s].precision ? e[s].precision : e[s].data.length);
                    break;
                case "x":
                    p = Math.abs(parseInt(e[s].data)).toString(16).toLowerCase();
                    break;
                case "X":
                    p = Math.abs(parseInt(e[s].data)).toString(16).toUpperCase();
                    break;
                default:
                    throw 'sprintf: Unknown type "' + e[s].type + '" detected. This should never happen. Maybe the regex is wrong.'
            }
            if ("%" != e[s].type) {
                if (0 != e[s].width && e[s].width > p.length)
                    for (var o = p.length, d = 0; d < e[s].width - o; ++d) p = 1 == e[s].alignLeft ? p + e[s].padding : e[s].padding + p;
                ("b" == e[s].type || "d" == e[s].type || "o" == e[s].type || "f" == e[s].type || "x" == e[s].type || "X" == e[s].type) && (1 == e[s].negative ? p = "-" + p : 1 == e[s].sign && (p = "+" + p)), n += p
            } else n += p
        }
        return n += t.substring(i, t.length)
    };
    return t.attach = function(a) {
        a.printf = function() {
            var a = Array.prototype.slice.call(arguments);
            return a.unshift(String(this)), t.apply(void 0, a)
        }
    }, t
});